# -*- coding: utf-8 -*-
"""the code

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QdUwVZjYp6valp_XAGg9EWsVgNnf_25e
"""

import numpy as np
import random
import matplotlib.pyplot as plt
from copy import deepcopy


def rbf_margin(x, theta, w):
    var = 0
    for i in range(noC):
        var += w[i]*x[i]
    return var + theta

def kmeans_func(old_centers, total_centers, c):
    clusters = np.zeros(len(c))
    error = np.linalg.norm(total_centers - old_centers, axis=1)
    
    while error.any() != 0:
        for i in range(len(c)):
            distances = np.linalg.norm(c[i]-total_centers, axis=1)
            cluster = np.argmin(distances)
            clusters[i] = cluster
        old_centers = deepcopy(total_centers)
        for i in range(k):
            elements = [c[j] for j in range(len(c)) if clusters[j] == i]
            total_centers[i] = np.mean(elements, axis=0)
        error = np.linalg.norm(total_centers - old_centers, axis=1)
    return total_centers

def signum_func(x):
    if x >= 0:
        y = 1
    else:
        y = -1
    return y

def misclassified(w, theta, x, d):
    miscal = 0
    for i in range(len(x)):
        y = np.dot(w.reshape(1,noC),np.asarray(x[i]).reshape(noC,1)) + theta
        y = signum_func(y)
        if y != d[i]:   
            miscal = miscal +1
    return miscal

  
num = 100
d = []
c1 = []
c_1 = []
x = np.random.uniform(0,1,(100 ,2))

for i in range(num):
    if x[i][1] < ((0.2 * np.sin(10*x[i][0])) + 0.3) or ((x[i][1] - 0.8)**2 +(x[i][0] - 0.5)**2 < 0.15**2):
        d.append(1)
        c1.append(x[i])
    else:
        d.append(-1)
        c_1.append(x[i])

# Centre numbers - Change here for 20 or 4
print('Please Enter number of centres')
noC= int(input())


rc1 = random.sample(range(len(c1)), k = int(noC/2))
rc_1 = random.sample(range(len(c_1)), k = int(noC/2))

centers_c1 = []
centers_c2 = []

for i in range(len(rc1)):
    centers_c1.append(c1[i])

for i in range(len(rc_1)):
    centers_c2.append(c_1[i])
total_centers = centers_c1 + centers_c2

fig, ax = plt.subplots(figsize=(10,10))
plt.scatter(*zip(*c1), c = 'red', label = 'Class 1')
plt.scatter(*zip(*c_1), c = 'pink', label = 'Class -1')
plt.scatter(*zip(*centers_c1), c='black', label = 'Class 1 centers')
plt.scatter(*zip(*centers_c2), c='green', label = 'Class -1 centers')
plt.legend(loc = 'best')
plt.show()

#Updating the centers based on distance calculation


centers_c1 = np.asarray(centers_c1)
centers_c2 = np.asarray(centers_c2)

k= int(noC/2)

    
centers_c1_old = np.zeros(centers_c1.shape)
updated_centers_c1 = kmeans_func(centers_c1_old, centers_c1, c1)

centers_c2_old = np.zeros(centers_c2.shape)
updated_centers_c2 = kmeans_func(centers_c2_old, centers_c2, c_1)


#Updated Centers Plot
fig, ax = plt.subplots(figsize=(10,10))
plt.scatter(*zip(*c1), c = 'red', label = 'Class 1')
plt.scatter(*zip(*c_1), c = 'pink', label = 'Class -1')
plt.scatter(*zip(*updated_centers_c1), c='black', label = 'Class 1 centers')
plt.scatter(*zip(*updated_centers_c2), c='green', label = 'Class -1 centers')
plt.legend(loc = 'best')
plt.show()

updated_centers = np.concatenate((updated_centers_c1, updated_centers_c2))

w = np.random.uniform(-1, 1, size=noC)
theta = np.random.uniform(-1, 1)
eta = 0.25

new_x = []
for i in range(len(x)):
    buffer = []
    for j in range(len(updated_centers)):
        check = (np.linalg.norm(x[i] - updated_centers[j], axis=0))
        buffer.append(check)
    new_x.append(buffer)


if noC==20:
  a=10
else:
  a=20
  
error = misclassified(w, theta, new_x, d)    

while error > a:
    for i in range(len(new_x)):
        y = np.dot(w.reshape(1,noC),np.asarray(new_x[i]).reshape(noC,1)) + theta
        y = signum_func(y)
        if y != d[i]:
            update = np.asarray(new_x[i])*eta*(d[i]-y)
            w = np.add(w, update)
    error = misclassified(w, theta, new_x, d)
    print(error)


x_coord = np.linspace(0.0, 1.0, num=1000)
y_coord = np.linspace(0.0, 1.0, num=1000)
h = []

for i in x_coord:
    for j in y_coord:
        coord = [i, j]
        new_coord = []
        for k in range(noC):
            mod = np.linalg.norm(coord - updated_centers[k], axis=0)
            new_coord.append(mod)
        g = rbf_margin(new_coord, theta, w)
        if -0.001 < g < 0.001:
            h.append(coord)

fig, ax = plt.subplots(figsize=(10,10))
plt.scatter(*zip(*c1), c = 'red', label = 'Class 1')
plt.scatter(*zip(*c_1), c = 'pink', label = 'Class -1')
plt.scatter(*zip(*h), c = 'blue',s=1, label = 'Margin')
plt.legend(loc = 'best')
plt.show()